from sklearn import svm
import numpy as np
import pickle
import os
from analysis_plot import *
import sklearn

working_path = os.path.dirname(os.path.abspath(__file__))
feature_folder_name = 'extracted_feats'
saved_feature_path = working_path + '/../' + feature_folder_name


def rfe_dict(all_features):
    """

    :param all_features: dict with all families and features
    :return: a rfe version of all features
    """
    with open(saved_feature_path + '/f1_reduced_mask', 'rb') as fp:
        mask = pickle.load(fp)
    # rfe each sample
    all_features_rfe = {}
    for family in all_features:
        feature_mat = all_features.get(family)
        feature_mat_rfe = list()
        for i in range(len(feature_mat)):
            feature_vec = list()
            for j in range(len(mask)):
                if mask[j]:
                    feature_vec.append(feature_mat[i][j])
            feature_mat_rfe.append(feature_vec)
        all_features_rfe[family] = feature_mat_rfe.copy()
    return all_features_rfe


def generate_probability_file():
    """

    Generating probabilities of each malware sample being assigned to its according family
    :return: A list of 25 lists. Each list contains the probability of each malware sample being assigned to its own family
    """

    with open(saved_feature_path + '/f1_all_features', 'rb') as fp:
        all_features = pickle.load(fp)
    n_families = 25
    num_fold = 5
    prob_of_each_point = [[] for i in range(n_families)]

    #rfe each sample
    all_features_rfe = rfe_dict(all_features)

    for i in range(num_fold):
        training_set = list()
        training_labels = list()
        testing_set = list()
        testing_labels = list()
        for family in all_features_rfe:
            feature_mat_rfe = all_features_rfe.get(family)

            fold_start = i * int(len(feature_mat_rfe) / num_fold)
            fold_end = fold_start + int(len(feature_mat_rfe) / num_fold) - 1

            for j in range(len(feature_mat_rfe)):
                if fold_start <= j <= fold_end:
                    testing_set.append(feature_mat_rfe[j])
                    testing_labels.append(family)
                else:
                    training_set.append(feature_mat_rfe[j])
                    training_labels.append(family)
        model = svm.SVC(probability=True)
        model.fit(training_set, training_labels)

        for family in all_features:
            x = []
            for each in testing_labels:
                if each == family:
                    x.append(testing_set[testing_labels.index(each)])
            prob = model.predict_proba(x)
            ind = list(all_features_rfe.keys())
            for each_sample in prob:
                prob_of_each_point[ind.index(family)].append(each_sample[ind.index(family)])
        print('The', i, '-th fold of', num_fold)
    with open (saved_feature_path + '\prob_of_each_sample_'+ str(n_families) + 'families', 'wb') as fp:
        pickle.dump(prob_of_each_point, fp)


def min_probabilities(p = 0.0):
    """

    :param p: p percentage, int(0 < p < 1)
    :return: list of families with min(can be tuned) probabilities larger than p
    """

    min_prob = []
    with open(saved_feature_path + '/prob_of_each_sample_25families', 'rb') as fp:
        prob = pickle.load(fp)
    for each in prob:
        min_prob.append(min(each))
    min_prob = np.asarray(min_prob)
    index_families = np.where(min_prob >= p)[0].tolist()
    return index_families, min_prob



def detect_benign(index_families):
    """

    :param index_families: list of families(index) that will be used to detect benign
    :return: accuracy rate of detecting benign, float 0-1
    """
    with open(saved_feature_path + '/f1_all_features', 'rb') as fp:
        all_features = pickle.load(fp)
    with open(saved_feature_path + '/benign_features', 'rb') as fp:
        benign = pickle.load(fp)
    with open(saved_feature_path + '/f1_reduced_mask', 'rb') as fp:
        mask = pickle.load(fp)
    families = list(all_features.keys())
    families_used = []
    for item in index_families:
        families_used.append(families[item])
    all_features_rfe = rfe_dict(all_features)
    num_fold = 5
    prob_of_selected_fam = [[] for i in range(len(families_used))]
    minprob = []
    benign_prob = []
    benign_prob_family = np.zeros((len(benign), len(families_used)))
    # rfe benign
    benign_rfe = list()
    for t in range(len(benign)):
        benign_vec = list()
        for j in range(len(mask)):
            if mask[j]:
                benign_vec.append(benign[t][j])
        benign_rfe.append(benign_vec)

    for i in range(num_fold):
        print('The', i, '-th fold of', num_fold)
        training_set = list()
        training_labels = list()
        testing_set = list()
        testing_labels = list()
        for family in families_used:
            feature_mat_rfe = all_features_rfe.get(family)
            fold_start = i * int(len(feature_mat_rfe) / num_fold)
            fold_end = fold_start + int(len(feature_mat_rfe) / num_fold) - 1
            for j in range(len(feature_mat_rfe)):
                if fold_start <= j <= fold_end:
                    testing_set.append(feature_mat_rfe[j])
                    testing_labels.append(family)
                else:
                    training_set.append(feature_mat_rfe[j])
                    training_labels.append(family)
        model = svm.SVC(probability=True)
        model.fit(training_set, training_labels)
        benign_prob.append(model.predict_proba(benign_rfe))
        for family in families_used:
            x = []
            for each in testing_labels:
                if each == family:
                    x.append(testing_set[testing_labels.index(each)])
            prob = model.predict_proba(x)
            for each_sample in prob:
                families_used_index = families_used.index(family)
                prob_of_selected_fam[families_used_index].append(each_sample[families_used_index])
    with open(saved_feature_path + '\prob_of_selected_fam_'+ str(len(families_used))+ 'families', 'wb') as fp:
        pickle.dump(prob_of_selected_fam, fp)  # prob_of_selected_fam里面包含的是families的list，每个list是每一个sample
        # 被分在这个famliy里面的概率组成的list

    for each in prob_of_selected_fam:
        minprob.append(min(each))
    minprob = np.asarray(minprob)

    prob_benign_arr = np.asarray(benign_prob)  # prob_benign_arr.shape = (5,120,25)
    for i in range(len(benign)):
        each_row = np.zeros((num_fold, len(families_used)))
        for j in range(len(prob_benign_arr)):
            # prob_benign_arr[j].shape = (120,25); #prob_benign_arr[j].shape = (120,25)
            each_row[j, :] = prob_benign_arr[j][i, :]
        benign_prob_family[i, :] = np.amax(each_row, axis=0)
    with open(saved_feature_path + '\prob_benign'+ str(len(families_used))+ 'families', 'wb') as fp:
        pickle.dump(benign_prob_family, fp)
    accu = 0
    for each in benign_prob_family:
        diff = each - minprob
        max = np.amax(diff)
        if max < 0:
            accu += 1
    accu_rate = accu/len(benign)
    return accu_rate, families_used


def benign_detection_rate():
    """

    :return: A list of accuracy rate. len = 24
              benign detection rate with respect to different number of families used. (2:25)

    """

    index_f, min_prob = min_probabilities(p = 0.0)
    min_prob = min_prob.tolist()
    print(min_prob)
    print('The unsorted min_prob is\n', min_prob)
    sorted_min_prob = sorted(min_prob, reverse=True)
    print('The sorted min_prob is\n', sorted_min_prob)
    accu_rate_list = []
    used_families_list = []
    for each in sorted_min_prob[1:]:  # starting from 2 families (top 2 to top 25)
        print(each)
        index_f, min_prob = min_probabilities(each)
        accu_rate, families_used = detect_benign(index_f)
        accu_rate_list.append(accu_rate)
        used_families_list.append(families_used)
        print('Using top', len(families_used), 'families to train the model')
        print('The accuracy rate is:', accu_rate, '\n')
    print('The accuracy list is:', accu_rate_list)
    print(used_families_list)
    with open(saved_feature_path + '\ benign_accu_rate_with_top_families', 'wb') as fp:
        pickle.dump(accu_rate_list, fp)


def larger_count(l, a):
    """

    :param l: list of float number
    :param a: counting condition. a:float, Counting the number of elements in l that are larger than a
    :return: the number of elements in l that are larger than a
    """
    n = len(l)
    count = 0
    for element in l:
        if element >= a:
            count += 1
    return count


def get_FPR_TPR(number_of_families):
    with open(saved_feature_path + '/prob_benign'+str(number_of_families)+'families', 'rb') as fp:
        benign_prob = pickle.load(fp)
    prob_benign_arr = np.asarray(benign_prob)
    minprob = []
    n = 50  # the number of thresholds
    with open(saved_feature_path + '/prob_of_selected_fam_'+str(number_of_families)+'families', 'rb') as fp:
        prob_of_selected_fam = pickle.load(fp)
    for each in prob_of_selected_fam:
        minprob.append(min(each))

    # setting threshold
    minprob = np.asarray(minprob)
    arg = (1 - minprob)/n

    fpr_list = []
    tpr_list = []
    for i in range(n):
        threshold = i * arg + minprob
        fn = 0
        tp = 0
        tn = 0
        fp = 0
        for each in prob_benign_arr:
            diff = each - threshold
            diff_max = np.amax(diff)
            if diff_max > 0:
                fp += 1
            else:
                tn += 1
        for j in range(len(prob_of_selected_fam)): # in each family
            accu_malware = larger_count(prob_of_selected_fam[j], threshold[j])
            tp += accu_malware
            fn += len(prob_of_selected_fam[j]) - accu_malware
        tpr = tp/(tp + fn)
        tnr = tn/(tn + fp)
        fpr = 1 - tnr
        fpr_list.append(fpr)
        tpr_list.append(tpr)
    return fpr_list, tpr_list


x, y = get_FPR_TPR(23)
print(sklearn.metrics.auc(x,y))
print(x)
print(y)
plot_roc(x, y)

