from sklearn import svm
import pickle
import os
from analysis_plot import *
import sklearn

working_path = os.path.dirname(os.path.abspath(__file__))
feature_folder_name = 'extracted_feats'
saved_feature_path = working_path + '/../' + feature_folder_name


def rfe_dict(all_features):
    """
    Apply a RFE mask for horizontal-edge feature.
    :param all_features: dict with all families and features
    :return: a rfe version of all features
    """
    with open(saved_feature_path + '/f1_reduced_mask', 'rb') as fp:
        mask = pickle.load(fp)

    # rfe each sample
    all_features_rfe = {}
    for family in all_features:
        feature_mat = all_features.get(family)
        feature_mat_rfe = list()
        for i in range(len(feature_mat)):
            feature_vec = list()
            for j in range(len(mask)):
                if mask[j]:
                    feature_vec.append(feature_mat[i][j])
            feature_mat_rfe.append(feature_vec)
        all_features_rfe[family] = feature_mat_rfe.copy()
    return all_features_rfe


def train_and_prepare_probability(index_families=list(range(25))):
    """
    1. Train a SVM model with a probability.
    2. Save the probability that is being classified correctly in `prob_of_selected_fam`
    3. Save the probability of testing samples (malware and benign) in folder /prob_malware and /prob_benign
    :param index_families: list of families(index) that will be used to detect benign
                            default is using all 25 families.
    :return:
    """
    with open(saved_feature_path + '/f1_all_features', 'rb') as fp:
        all_features = pickle.load(fp)
    with open(saved_feature_path + '/benign_features', 'rb') as fp:
        benign = pickle.load(fp)
    with open(saved_feature_path + '/f1_reduced_mask', 'rb') as fp:
        mask = pickle.load(fp)
    families = list(all_features.keys())
    families_used = []
    for item in index_families:
        families_used.append(families[item])

    all_features_rfe = rfe_dict(all_features)
    num_fold = 5

    # prob_of_selected_fam:
    #   contains a list of families. Each family list contains a list of probability that is
    #   being classified correctly.
    prob_of_selected_fam = [[] for i in range(len(families_used))]

    benign_prob = []  # starts with different folds
    benign_prob_family = np.zeros((len(benign), len(families_used)))
    malware_prob = []

    # generate benign feature in RFE version
    benign_rfe = list()
    for t in range(len(benign)):
        benign_vec = list()
        for j in range(len(mask)):
            if mask[j]:
                benign_vec.append(benign[t][j])
        benign_rfe.append(benign_vec)

    for i in range(num_fold):
        print('The', i, '-th fold of', num_fold)
        training_set = list()
        training_labels = list()
        testing_set = list()
        testing_labels = list()
        for family in families_used:
            feature_mat_rfe = all_features_rfe.get(family)
            fold_start = i * int(len(feature_mat_rfe) / num_fold)
            fold_end = fold_start + int(len(feature_mat_rfe) / num_fold) - 1
            for j in range(len(feature_mat_rfe)):
                if fold_start <= j <= fold_end:
                    testing_set.append(feature_mat_rfe[j])
                    testing_labels.append(family)
                else:
                    training_set.append(feature_mat_rfe[j])
                    training_labels.append(family)
        model = svm.SVC(probability=True)
        model.fit(training_set, training_labels)
        benign_prob.append(model.predict_proba(benign_rfe))
        malware_prob.append(model.predict_proba(testing_set))

        # save the training probability (threshold) for testing
        for family in families_used:
            x = []
            for each in testing_labels:
                if each == family:
                    x.append(testing_set[testing_labels.index(each)])
            prob = model.predict_proba(x)
            for each_sample in prob:
                families_used_index = families_used.index(family)
                prob_of_selected_fam[families_used_index].append(each_sample[families_used_index])

    with open(saved_feature_path + '/prob_of_selected_fam_' + str(len(families_used)) + 'families', 'wb') as fp:
        pickle.dump(prob_of_selected_fam, fp)

    # producing malware probability for testing
    # e.g. prob_malware_arr.shape = (5,200,25) <- 5-folds, 25 families, 200 samples
    prob_malware_arr = np.asarray(malware_prob)
    malware_testing_len = int(prob_malware_arr.shape[1])
    malware_prob_family = np.zeros((malware_testing_len, len(families_used)))
    for i in range(malware_testing_len):
        each_row = np.zeros((num_fold, len(families_used)))
        for j in range(len(prob_malware_arr)):
            each_row[j, :] = prob_malware_arr[j][i, :]
        malware_prob_family[i, :] = np.amax(each_row, axis=0)
    with open(saved_feature_path + '/prob_malware' + str(len(families_used)) + 'families', 'wb') as fp:
        pickle.dump(malware_prob_family, fp)

    # producing benign probability for testing
    # e.g. prob_benign_arr.shape = (5,120,25) <- 5-folds, 25 families, 120 samples
    prob_benign_arr = np.asarray(benign_prob)
    for i in range(len(benign)):
        each_row = np.zeros((num_fold, len(families_used)))
        for j in range(len(prob_benign_arr)):
            each_row[j, :] = prob_benign_arr[j][i, :]
        benign_prob_family[i, :] = np.amax(each_row, axis=0)
    with open(saved_feature_path + '/prob_benign' + str(len(families_used)) + 'families', 'wb') as fp:
        pickle.dump(benign_prob_family, fp)

    return


def get_fpr_tpr(number_of_families, use_all_threshold=True):
    """
    Testing phase.
    Generate FPR and TPR for ROC curve and AUC by taking the generated malware and benign probability.
    :param number_of_families:
    :param use_all_threshold:
    :return:
    """
    with open(saved_feature_path + '/prob_benign' + str(number_of_families) + 'families', 'rb') as fp:
        benign_prob = pickle.load(fp)
    with open(saved_feature_path + '/prob_malware' + str(number_of_families) + 'families', 'rb') as fp:
        malware_prob = pickle.load(fp)
    prob_benign_arr = np.asarray(benign_prob)
    prob_malware_arr = np.asarray(malware_prob)
    minprob = []
    n = 50  # the number of threshold scales
    with open(saved_feature_path + '/prob_of_selected_fam_' + str(number_of_families) + 'families', 'rb') as fp:
        prob_of_selected_fam = pickle.load(fp)

    for each in prob_of_selected_fam:
        if not use_all_threshold:
            std = np.asarray(each).std()
            minprob.append(max(min(each), 0))
        else:
            minprob.append(0)

    # setting threshold
    minprob = np.asarray(minprob)
    arg = (1 - minprob) / (n - 1)

    fpr_list = []
    tpr_list = []
    for i in range(n):
        threshold = i * arg + minprob
        fn, tp, tn, fp = 0, 0, 0, 0
        for each in prob_benign_arr:
            diff = each - threshold
            # amax: Return the maximum of an array or maximum along an axis.
            # if no one can even larger than the threshold, detect it to benign
            diff_max = np.amax(diff)
            if diff_max >= 0:
                fp += 1
            else:
                tn += 1

        for each in prob_malware_arr:
            diff = each - threshold
            diff_max = np.amax(diff)
            if diff_max >= 0:
                tp += 1
            else:
                fn += 1

        all_benign = tn + fp
        all_malware = tp + fn

        tpr = tp/(tp + fn)
        tnr = tn/(tn + fp)
        fpr = 1 - tnr
        fpr_list.append(fpr)
        tpr_list.append(tpr)

    print('num families:', number_of_families)
    print('malware count:', all_malware)
    print('benign count:', all_benign)

    return fpr_list, tpr_list


def get_roc_auc():
    """
    Plot ROC curve and get an AUC for malware/benign detection
    :return:
    """
    fpr, tpr = list(), list()
    labels = list()
    roc_auc = list()
    for i in range(18, 26):
        x, y = get_fpr_tpr(i)
        x.reverse()
        y.reverse()
        x.append(1.0)
        y.append(1.0)
        roc_auc.append(sklearn.metrics.auc(x, y))
        fpr.append(x)
        tpr.append(y)
        labels.append('Top ' + str(i) + ' models')

    plot_roc(fpr, tpr, multiple_curve=True, labels=labels)
    print(roc_auc)
    return roc_auc


def plot_auc_bar():
    """
    Plot a bar chart by AUCs
    Noted that the AUC can be acquired by `get_roc_auc()`
    """
    labels = list()
    for i in range(18, 26):
        labels.append('Top ' +  str(i) + ' models')

    AUC_UNIFORM = [0.9964807038592283, 0.996028916617152, 0.9969765961613788, 0.9985543728423475, 0.9983716203441104, 0.9959581253466445, 0.9879396755968654, 0.9889397201291712]
    AUC_MIN = [0.9863277344531094, 0.9890151515151514, 0.9841558950254602, 0.9752253548139624, 0.9043155605974665, 0.8305255130338325, 0.793425369054128, 0.7561849659131682]
    AUC_MIN_STD2 = [0.9843906218756249, 0.9867028124381066, 0.9721161378770073, 0.9229382431914077, 0.7948217999621856, 0.768667960806064, 0.7910880262438491, 0.8018702906350914]
    auc = [AUC_UNIFORM, AUC_MIN_STD2, AUC_MIN]

    AUC_DECODE = [0.814, 0.782, 0.764, 0.754, 0.744, 0.734, 0.731, 0.720]
    AUC_ENCODE = [0.732, 0.711, 0.681, 0.677, 0.677, 0.663, 0.649, 0.649]
    AUC_MIX = [0.810, 0.779, 0.763, 0.745, 0.734, 0.726, 0.722, 0.720]

    auc = [AUC_MIN, AUC_MIX]
    plot_bar(auc, 'AUC Comparison', labels=labels, legends=['Machine learning', 'Robust hashing'])
    # plot_bar(auc, 'Different constraint', labels=labels, legends=['Exhaustive Search', 'Min prob - 2 std', 'Min prob'])


if __name__ == '__main__':
    # train_and_prepare_probability()
    # get_roc_auc()
    plot_auc_bar()


# ------ Opt-out functions ------
# The following functions are not used anymore
# --------------------------------------------
def generate_probability_file():
    """
    !! OBSOLETE FUNCTION !!
    Generating probabilities of each malware sample being classified to its according family
    :return: A list of 25 lists. Each list contains the probability of each malware sample being assigned to its own family
    """

    with open(saved_feature_path + '/f1_all_features', 'rb') as fp:
        all_features = pickle.load(fp)
    n_families = 25
    num_fold = 5
    prob_of_each_point = [[] for i in range(n_families)]

    #rfe each sample
    all_features_rfe = rfe_dict(all_features)

    for i in range(num_fold):
        training_set = list()
        training_labels = list()
        testing_set = list()
        testing_labels = list()
        for family in all_features_rfe:
            feature_mat_rfe = all_features_rfe.get(family)

            fold_start = i * int(len(feature_mat_rfe) / num_fold)
            fold_end = fold_start + int(len(feature_mat_rfe) / num_fold) - 1

            for j in range(len(feature_mat_rfe)):
                if fold_start <= j <= fold_end:
                    testing_set.append(feature_mat_rfe[j])
                    testing_labels.append(family)
                else:
                    training_set.append(feature_mat_rfe[j])
                    training_labels.append(family)
        model = svm.SVC(probability=True)
        model.fit(training_set, training_labels)

        for family in all_features:
            x = []
            for each in testing_labels:
                if each == family:
                    x.append(testing_set[testing_labels.index(each)])
            prob = model.predict_proba(x)  # predict_prob will return all probabilities to each sub-models
                                           # e.g. one sample will output 25 probbilites.

            ind = list(all_features_rfe.keys()).index(family)
            for each_sample in prob:
                prob_of_each_point[ind].append(each_sample[ind])
        print('The', i, '-th fold of', num_fold)
    return
    with open(saved_feature_path + '/prob_of_each_sample_' + str(n_families) + 'families', 'wb') as fp:
        pickle.dump(prob_of_each_point, fp)


def min_probabilities(p=0.0):
    """
    !! OBSOLETE FUNCTION !!
    :param p: p percentage, int(0 < p < 1)
    :return: list of families with min(can be tuned) probabilities larger than p
    """

    min_prob = []
    with open(saved_feature_path + '/prob_of_each_sample_25families', 'rb') as fp:
        prob = pickle.load(fp)
    for each in prob:
        min_prob.append(min(each))
    min_prob = np.asarray(min_prob)
    index_families = np.where(min_prob >= p)[0].tolist()
    return index_families, min_prob


def benign_detection_rate():
    """
    !! OBSOLETE FUNCTION !!
    :return: A list of accuracy rate. len = 24
              benign detection rate with respect to different number of families used. (2:25)

    """

    index_f, min_prob = min_probabilities(p=0.0)
    min_prob = min_prob.tolist()
    print(min_prob)
    print('The unsorted min_prob is\n', min_prob)
    sorted_min_prob = sorted(min_prob, reverse=True)
    print('The sorted min_prob is\n', sorted_min_prob)
    for each in sorted_min_prob[1:]:  # starting from 2 families (top 2 to top 25)
        print(each)
        index_f, min_prob = min_probabilities(p=each)
        train_and_prepare_probability(index_f)
# --------------------------------------------
