from sklearn import svm
import numpy as np
import pickle
import os

working_path = os.path.dirname(os.path.abspath(__file__))
feature_folder_name = 'extracted_feats'
saved_feature_path = working_path + '/../' + feature_folder_name


def rfe_dict(all_features):
    """

    :param all_features: dict with all families and features
    :return: a rfe version of all features
    """
    with open(saved_feature_path + '/f1_reduced_mask', 'rb') as fp:
        mask = pickle.load(fp)
    # rfe each sample
    all_features_rfe = {}
    for family in all_features:
        feature_mat = all_features.get(family)
        feature_mat_rfe = list()
        for i in range(len(feature_mat)):
            feature_vec = list()
            for j in range(len(mask)):
                if mask[j]:
                    feature_vec.append(feature_mat[i][j])
            feature_mat_rfe.append(feature_vec)
        all_features_rfe[family] = feature_mat_rfe.copy()
    return all_features_rfe


def generate_probability_file():
    """
    Generating probabilities of each malware sample being assigned to its according family

    :return: A list of 25 lists. Each list contains the probability of each malware sample being assigned to its own family

    """

    with open(saved_feature_path + '/f1_all_features', 'rb') as fp:
        all_features = pickle.load(fp)
    n_families = 25
    num_fold = 5
    prob_of_each_point = [[] for i in range(n_families)]

    #rfe each sample
    all_features_rfe = rfe_dict(all_features)

    for i in range(num_fold):
        training_set = list()
        training_labels = list()
        testing_set = list()
        testing_labels = list()
        for family in all_features_rfe:
            feature_mat_rfe = all_features_rfe.get(family)

            fold_start = i * int(len(feature_mat_rfe) / num_fold)
            fold_end = fold_start + int(len(feature_mat_rfe) / num_fold) - 1

            for j in range(len(feature_mat_rfe)):
                if fold_start <= j <= fold_end:
                    testing_set.append(feature_mat_rfe[j])
                    testing_labels.append(family)
                else:
                    training_set.append(feature_mat_rfe[j])
                    training_labels.append(family)
        model = svm.SVC(probability=True)
        model.fit(training_set, training_labels)

        for family in all_features:
            x = []
            for each in testing_labels:
                if each == family:
                    x.append(testing_set[testing_labels.index(each)])
            prob = model.predict_proba(x)
            ind = list(all_features_rfe.keys())
            for each_sample in prob:
                prob_of_each_point[ind.index(family)].append(each_sample[ind.index(family)])
        print('The', i, '-th fold of', num_fold)
    with open (saved_feature_path + '\prob_of_each_sample_'+ str(n_families) + 'families', 'wb') as fp:
        pickle.dump(prob_of_each_point, fp)


def min_probabilities(p = 0.0):
    """
    :param p: p percentage, int(0 < p < 1)
    :return: list of families with min(can be tuned) probabilities larger than p
    """

    min_prob = []
    with open(saved_feature_path + '/prob_of_each_sample_25families', 'rb') as fp:
        prob = pickle.load(fp)
    for each in prob:
        min_prob.append(min(each))
    min_prob = np.asarray(min_prob)
    index_families = np.where(min_prob > p)[0].tolist()
    return index_families, min_prob


def rerun_probabilities(index_families):
    with open(saved_feature_path + '/f1_all_features', 'rb') as fp:
        all_features = pickle.load(fp)
    with open(saved_feature_path + '/f1_reduced_mask', 'rb') as fp:
        mask = pickle.load(fp)
    families = list(all_features.keys())
    families_used = []
    for item in index_families:
        families_used.append(families[item])
    all_features_rfe = rfe_dict(all_features)
    num_fold = 5
    prob_of_selected_fam = [[] for i in range(len(families_used))]
    minprob = []
    for i in range(num_fold):
        training_set = list()
        training_labels = list()
        testing_set = list()
        testing_labels = list()
        for family in families_used:
            feature_mat_rfe = all_features_rfe.get(family)
            fold_start = i * int(len(feature_mat_rfe) / num_fold)
            fold_end = fold_start + int(len(feature_mat_rfe) / num_fold) - 1
            for j in range(len(feature_mat_rfe)):
                if fold_start <= j <= fold_end:
                    testing_set.append(feature_mat_rfe[j])
                    testing_labels.append(family)
                else:
                    training_set.append(feature_mat_rfe[j])
                    training_labels.append(family)
        model = svm.SVC(probability=True)
        model.fit(training_set, training_labels)
        for family in families_used:
            x = []
            for each in testing_labels:
                if each == family:
                    x.append(testing_set[testing_labels.index(each)])
            prob = model.predict_proba(x)
            for each_sample in prob:
                prob_of_selected_fam[families_used.index(family)].append(each_sample[families_used.index(family)])
        print('The', i, '-th fold of', num_fold)
    for each in prob_of_selected_fam:
        minprob.append(min(each))
    minprob = np.asarray(minprob)
    return minprob


def detect_benign(index_families):
    """

    :param index_families: list of families(index) that will be used to detect benign
    :return: accuracy rate of detecting benign, float 0-1
    """
    with open(saved_feature_path + '/f1_all_features', 'rb') as fp:
        all_features = pickle.load(fp)
    with open(saved_feature_path + '/benign_features', 'rb') as fp:
        benign = pickle.load(fp)
    with open(saved_feature_path + '/f1_reduced_mask', 'rb') as fp:
        mask = pickle.load(fp)
    families = list(all_features.keys())
    families_used = []
    for item in index_families:
        families_used.append(families[item])
    all_features_rfe = rfe_dict(all_features)
    num_fold = 5
    prob_of_selected_fam = [[] for i in range(len(families_used))]
    minprob = []
    benign_prob = [[] for i in range(num_fold)]
    benign_prob_family = np.zeros((len(benign), len(families_used)))
    # rfe benign
    benign_rfe = list()
    for t in range(len(benign)):
        benign_vec = list()
        for j in range(len(mask)):
            if mask[j]:
                benign_vec.append(benign[t][j])
        benign_rfe.append(benign_vec)

    for i in range(num_fold):
        print('The', i, '-th fold of', num_fold)
        training_set = list()
        training_labels = list()
        testing_set = list()
        testing_labels = list()
        for family in families_used:
            feature_mat_rfe = all_features_rfe.get(family)
            fold_start = i * int(len(feature_mat_rfe) / num_fold)
            fold_end = fold_start + int(len(feature_mat_rfe) / num_fold) - 1
            for j in range(len(feature_mat_rfe)):
                if fold_start <= j <= fold_end:
                    testing_set.append(feature_mat_rfe[j])
                    testing_labels.append(family)
                else:
                    training_set.append(feature_mat_rfe[j])
                    training_labels.append(family)
        model = svm.SVC(probability=True)
        model.fit(training_set, training_labels)
        benign_prob[i].append(model.predict_proba(benign_rfe))
        for family in families_used:
            x = []
            for each in testing_labels:
                if each == family:
                    x.append(testing_set[testing_labels.index(each)])
            prob = model.predict_proba(x)
            for each_sample in prob:
                prob_of_selected_fam[families_used.index(family)].append(each_sample[families_used.index(family)])

    for each in prob_of_selected_fam:
        minprob.append(min(each))
    minprob = np.asarray(minprob)

    prob_benign_arr = np.asarray(benign_prob)
    for each in prob_benign_arr:  # each is the i-th of fold
        for row in range(len(benign)):
            each_row = np.zeros((num_fold, len(families_used)))
            for i in range(len(each)):
                each_row[i][:] = each[i][row][:]
            benign_prob_family[row, :] = np.amax(each_row, axis=0)
    accu = 0
    for each in benign_prob_family:
        diff = each - minprob
        max = np.amax(diff)
        if max < 0:
            accu += 1
    accu_rate = accu/len(benign)
    return accu_rate


a = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0]
accu_rate_list = []
for each in a:
    index_f,min_prob = min_probabilities(each)
    accu_rate_list.append(detect_benign(index_f))
print(accu_rate_list)