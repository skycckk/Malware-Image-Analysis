from scipy.fftpack import dct
from scipy.fftpack import idct
from scipy.misc import imread

import matplotlib.pyplot as plt
import numpy as np


class JPGEncode:

    def __init__(self):
        pass

    @staticmethod
    def dct2(x):
        """
        Perform a 2D Discrete Cosine Transform.
        :param x: The input array
        :return: An array of DCT coefficients
        """
        return dct(dct(x, axis=0, norm='ortho'), axis=1, norm='ortho')

    @staticmethod
    def idct2(x):
        """
        Perform a 2D Inverse Discrete Cosine Transform.
        :param x: The input DCT coefficients
        :return: The transformed input array
        """
        return idct(idct(x, axis=0, norm='ortho'), axis=1, norm='ortho')

    def encode(self, img, bk_size=8, thresh=0.01, debug=False):
        """
        Encode an image with block-wise DCT transform with a scalar uniform quantization
        :param img: An 2D input image
        :param bk_size: Block size for DCT transform
        :param thresh: A threshold that specify the percentage of coefficient should be reduced
        :param debug: A flag to dump the compressed image
        :return: A codeword after a zig-zag scan
        """
        # Do 8x8 DCT on image (in-place)
        imsize = img.shape
        dct_coeff = np.zeros(imsize)
        for i in np.r_[:imsize[0]:bk_size]:
            for j in np.r_[:imsize[1]:bk_size]:
                dct_coeff[i:(i + bk_size), j:(j + bk_size)] = self.dct2(img[i:(i + bk_size), j:(j + bk_size)])

        dct_thresh = dct_coeff * (abs(dct_coeff) > (thresh * np.max(dct_coeff)))

        codeword = self.zigzagScan(dct_coeff.tolist())

        if debug:
            plt.figure()
            plt.imshow(img, cmap='gray')

            plt.figure()
            plt.imshow(dct_coeff, cmap='gray', vmax=np.max(dct_coeff) * 0.01, vmin=0)
            plt.title("8x8 DCTs of the image")

            plt.figure()
            plt.imshow(dct_thresh, cmap='gray', vmax=np.max(dct_coeff) * 0.01, vmin=0)
            plt.title("Thresholded 8x8 DCTs of the image")

            im_dct = np.zeros(imsize)
            for i in np.r_[:imsize[0]:bk_size]:
                for j in np.r_[:imsize[1]:bk_size]:
                    im_dct[i:(i + bk_size), j:(j + bk_size)] = self.idct2(dct_thresh[i:(i + bk_size), j:(j + bk_size)])
            plt.figure()
            plt.imshow(np.hstack((img, im_dct)), cmap='gray')
            plt.title("Comparison between original and DCT compressed images")

            plt.show()
            percent_nonzeros = np.sum(dct_thresh != 0.0) / (imsize[0] * imsize[1] * 1.0)
            print("Keeping only %f%% of the DCT coefficients" % (percent_nonzeros * 100.0))

        return codeword

    @staticmethod
    def zigzagScan(matrix):
        if matrix is None or len(matrix) is 0 or len(matrix[0]) is 0:
            return []

        m = len(matrix)
        n = len(matrix[0])
        i = j = 0
        res = [0] * (m * n)
        counter = 0
        res[counter] = matrix[i][j]
        counter += 1
        if j + 1 < n:
            j += 1
        else:
            i += 1

        while counter < m * n:
            while i < m and j >= 0:
                res[counter] = matrix[i][j]
                counter += 1
                i += 1
                j -= 1
            i -= 1
            j += 1
            if i + 1 < m:
                i += 1
            else:
                j += 1

            while i >= 0 and j < n:
                res[counter] = matrix[i][j]
                counter += 1
                i -= 1
                j += 1
            i += 1
            j -= 1
            if j + 1 < n:
                j += 1
            else:
                i += 1

        return res

if __name__ == '__main__':
    codec = JPGEncode()
    pass