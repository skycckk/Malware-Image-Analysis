from skimage import filters
from skimage import feature
from skimage import img_as_float
from skimage import exposure
from skimage import transform
from skimage.morphology import disk
import matplotlib.pyplot as plt
import numpy as np
import pywt
from skimage import io
from jpg_quantizer import *


def project_h_edge(img, gauss_sigma=1, print_img=False, total_blocks=-1):
    """
    Project horizontal edges vertically by processing an h_sobel operation followed by gaussian blur
    :param img: input gray image (0~255)
    :param gauss_sigma: sigma in gaussian distribution w.r.t. blurness
    :param print_img: print debug images
    :param total_blocks: number of blocks or intervals in image spreading vertically
    :return: histogram normalized to 0~1 and length is image height
    """
    img_height, img_width = img.shape[0], img.shape[1]
    img = img_as_float(img)
    blurred = filters.gaussian(img, gauss_sigma)
    edge_map = filters.sobel_h(blurred)
    if total_blocks is -1:
        total_blocks = img_height

    if print_img is True:
        dump_images(img, blurred, edge_map)

    hist_len = min(total_blocks, img_height)
    ratio = (hist_len - 1) / (img_height - 1)
    hist = [0] * hist_len
    peak_val = 0
    for i in range(img_height):
        hist_index = round(i * ratio)
        for j in range(img_width):
            hist[hist_index] += abs(edge_map[i][j])
        if hist[hist_index] > peak_val:
            peak_val = hist[hist_index]

    for i in range(hist_len):
        hist[i] /= peak_val

    return hist


def extract_HOG(img, blocks=(12, 12), buckets=64, print_img=False):
    """
    Extract Histogram of Gaussian features
    :param img: input 1-channel image
    :param blocks: block size of HOG in tuple(height, width). This controls the size of output vector
    :param buckets: number of buckets of HOG in the result feature vector
    :param print_img: visualize the HOG result
    :return: feature vector
    """
    img_height, img_width = img.shape[0], img.shape[1]
    # cut the image to fit the block
    block_len = blocks[0]

    # make k times of block
    new_height = block_len * int(img_height / block_len)
    new_width = block_len * int(img_width / block_len)
    pixels_per_cell = (int(new_width / block_len), int(new_height / block_len))

    if not print_img:
        arr = feature.hog(img[:new_height, :new_width],
                          pixels_per_cell=pixels_per_cell, block_norm='L2-Hys', visualise=False)

        mmax, mmin = 0, 0
        for k in range(len(arr)):
            mmax = max(mmax, arr[k])
            mmin = min(mmin, arr[k])
        for k in range(len(arr)):
            arr[k] = (arr[k] - mmin) / (mmax - mmin)

        bucket_len = len(arr) / buckets
        res = [0] * buckets
        res_count = [0] * buckets
        for i in range(len(arr)):
            bucket_id = int(i / bucket_len)
            res[bucket_id] += arr[i]
            res_count[bucket_id] += 1
        res = np.asarray(res) / np.asarray(res_count)
        return res

    else:
        arr, hog_img = feature.hog(img[:new_height, :new_width],
                                   pixels_per_cell=pixels_per_cell, block_norm='L2-Hys', visualise=True)
        fig = plt.figure()
        ax = fig.add_subplot(111)
        ax.imshow(hog_img, cmap="gray")
        plt.show()

        io.use_plugin('pil')
        dump = np.reshape(arr, (270, 270))
        mmax = 0
        mmin = 0
        for i in range(dump.shape[0]):
            for j in range(dump.shape[1]):
                mmax = max(mmax, dump[i][j])
                mmin = min(mmax, dump[i][j])

        print(mmax, mmin)
        for i in range(dump.shape[0]):
            for j in range(dump.shape[1]):
                dump[i][j] = (dump[i][j] - mmin) * 255 / (mmax - mmin)
    return arr


def extract_grid_blocks(img, blocks_per_image=(3, 3)):
    """
    Divide image into grids(blocks)
    :param img: input 1-channel image
    :param blocks_per_image: number of grids in tuple(height, width)
    :return: 2D list containing pixel value for each slot
    """
    img_height, img_width = img.shape[0], img.shape[1]
    bx = int(img_width / blocks_per_image[1])
    by = int(img_height / blocks_per_image[0])
    grids = []
    for i in range(blocks_per_image[0]):
        start_i = i * by
        end_i = start_i + by
        for j in range(blocks_per_image[1]):
            start_j = j * bx
            end_j = start_j + bx
            grid = img[start_i:end_i, start_j:end_j]
            grids.append(grid)

    return grids


def means_feature(grids):
    """
    Compute the mean value of pixel intensity in each grid of image
    :param grids: 2D list containing pixel value for each slot
    :return: mean vector
    """
    feature_vec = [0] * len(grids)
    for i in range(len(grids)):
        block = np.asarray(grids[i])
        feature_vec[i] = block.mean() / 255

    return feature_vec


def histogram_feature(img):
    """
    Compute the histogram in each grid
    :param img: ndarray
                1-channel image
    :return: concatenated histogram with value range from 0 to 1
    """
    hist, bin_centers = exposure.histogram(img)
    hist = hist / np.max(hist)
    feature_vec = hist.flatten().tolist()
    return feature_vec


def median_feature(img, resize_shape=(64, 64)):
    """
    Compute median feature applying a median filter
    :param img: ndarray
                1-channel image
    :param resize_shape: tuple(, )
                The output image size after applying median filter.
    :return: flatten feature vector of 2D median filtered image
    """
    img_med = filters.median(img, disk(7))
    img_med = transform.resize(img_med, resize_shape, mode='reflect')
    return img_med.flatten().tolist()


def extract_lbp_feature(img, radius=2):
    """
    Extract Local Binary Pattern(LBP) features
    :param img: ndarray
                1-channel image
    :param radius: int
                Number of circularly symmetric neighbour set points (quantization of the angular space).
    :return: list
                Histogram of LBP result
    """
    n_points = 8 * radius
    lbp = feature.local_binary_pattern(img, n_points, radius, method="uniform")
    n_bins = int(lbp.max() + 1)
    hist, _ = np.histogram(lbp, normed=True, bins=n_bins, range=(0, n_bins))
    return hist.tolist()


def frequency_feature(img, line_bk=1):
    """
    Extract a frequency distribution
    :param img: ndarray
                1-channel image
    :param line_bk: int
                Number of horizontal segments. (default is 1, an whole image)
    :return: list
                The frequency distribution over the number of horizontal segments. (i.e. 8x8 DCT with line_nk=4 will
                produce 64 * 4 vector length)
    """
    # Align the input image to the block size of DCT (i.e. align to 8) to unify DCT coefficient matrix
    height = int(img.shape[0] / 8) * 8
    width = int(img.shape[1] / 8) * 8
    if height < 1 or width < 1:
        raise ValueError('Input image size should greater than the DCT block size')

    img_aligned = img[0:height, 0:width]

    codec = JPGEncode()
    codeword = codec.encode(img_aligned, bk_size=8, thresh=0.1, use_qtm=True, debug=False)
    n = len(codeword)

    height_in_bk = int(height / 8)
    width_in_bk = int(width / 8)
    feature_vec = list()
    line_seg_size = height_in_bk / line_bk
    if line_seg_size < 1:
        raise ValueError('line_bk should less than the height / DCT_bk_size')
    for i in np.r_[:height_in_bk:line_seg_size]:
        start = int(i) * width_in_bk
        end = int(i + line_seg_size) * width_in_bk

        freq_size = 8 * 8
        freq_distribution = [0] * freq_size
        for j in range(start, end):
            for k in range(freq_size):
                freq_distribution[k] += abs(codeword[j][k])

        for k in range(freq_size):
            freq_distribution[k] = round(freq_distribution[k] / n)

        feature_vec += freq_distribution

    return feature_vec


def wavelet_features(img, wt_levels=5, bk=8, quantized=True):
    """
    Extract statistical features based on images subband by using wavelet transform.
    For each band, (random) tiling to get means or variances.
    Get means for coarse bands.
    Get variances for the rest bands.
    :param img: ndarray
                1-channel image
    :param wt_levels: Level of wavelet transform
    :param bk: Size of each cell. The total block numbers is bk * bk
    :param quantized: Indicate whether to quantize the feature vector by a uniform distribution.
    :return: A list.
    """
    subbands = [0] * wt_levels
    for i in range(wt_levels):
        coeffs = pywt.dwt2(img, 'haar')
        cA, (cH, cV, cD) = coeffs
        img = cA
        subbands[i] = img

    feature_vec = [0] * (bk * bk * wt_levels)
    cnt = 0
    for i in range(wt_levels):
        img = subbands[i]
        height, width = img.shape[0], img.shape[1]
        for j in np.r_[0:height:height / bk]:
            start_i = int(round(j))
            end_i = int(round(j + height / bk))
            for k in np.r_[0:width:width / bk]:
                start_j = int(round(k))
                end_j = int(round(k + width / bk))
                block = img[start_i:end_i, start_j:end_j]
                if 0 <= i <= 1:
                    feature_vec[cnt] = np.var(block)
                else:
                    feature_vec[cnt] = np.mean(block)
                cnt += 1

    if quantized:
        max_r = np.max(feature_vec)
        min_r = np.min(feature_vec)
        interval = (max_r - min_r) / 8.0
        for i in range(len(feature_vec)):
            feature_vec[i] = int((feature_vec[i] - min_r - 1) / interval)

    return feature_vec


def convolution(img):
    pass
    # NOT IMPLEMENTED YET
    # kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])
    # # you can use 'valid' instead of 'same', then it will not add zero padding
    # image_sharpen = scipy.signal.convolve2d(img, kernel, 'same')


def get_features(img, name):
    """
    Get features with specific one
    :param img: ndarray
            1-channel input byte image
    :param name: string
            type of feature using
    :return: list
            1D feature vector
    """
    if name == 'h-edge':  # horizontal edge: 1 x 256
        smooth_radius = 3
        hist_size = 256
        # original setting: 9 and 256
        # tuned setting: 3 and 64
        hist = project_h_edge(img, gauss_sigma=smooth_radius, print_img=False, total_blocks=hist_size)

        # resize to desired length. e.g. 256
        hist_arr = np.array(hist).reshape(1, len(hist))
        feature_vec = transform.resize(hist_arr, (1, hist_size), mode='reflect').tolist()[0]

    elif name == 'hog':  # Histogram of Gaussian
        hog_block_size = (4, 4)
        hog_buckets = 128
        # original setting: (12, 12) and 1
        # tuned setting: (4, 4) and 128
        feature_vec = extract_HOG(img, blocks=hog_block_size, buckets=hog_buckets).tolist()

    elif name == 'mean':  # Mean intensity of each grid
        # ---------------------------
        # if not using mean value, the dimension would be 8100
        # ---------------------------
        grid_block_size = (16, 16)
        # original setting: (3, 3)
        # tuned setting: (16, 16)
        grids = extract_grid_blocks(img, blocks_per_image=grid_block_size)
        feature_vec = means_feature(grids)

    elif name == 'lbp':  # Local Binary Pattern
        lbp_radius = 2
        # original setting: 2
        # tuned setting: 2
        feature_vec = extract_lbp_feature(img, radius=lbp_radius)

    elif name == 'contrast':  # Histogram(Contrast)
        feature_vec = histogram_feature(img)

    elif name == 'median':  # median images (flatten)
        median_shape = (64, 64)
        # original setting: (64, 64)
        # tuned setting: (64, 64)
        feature_vec = median_feature(img, resize_shape=median_shape)

    return feature_vec


def dump_images(img, blur_img, edge_map):
    abs_edge_map = np.abs(edge_map)
    max_edge = np.max(abs_edge_map)
    new_edge_map = (abs_edge_map * 255) / max_edge
    fig = plt.figure()
    ax1 = fig.add_subplot(131)
    ax2 = fig.add_subplot(132)
    ax3 = fig.add_subplot(133)
    ax1.set_title("source")
    ax2.set_title("blurred")
    ax3.set_title("edge map")
    ax1.imshow(img, cmap="gray")
    ax2.imshow(blur_img, cmap="gray")
    ax3.imshow(new_edge_map, cmap="gray")
    plt.tight_layout()
    plt.show()