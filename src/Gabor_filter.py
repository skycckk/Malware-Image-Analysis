import numpy as np
import cv2
import load_image
from PIL import Image
import matplotlib.image as mpimg
import pylab as pl



def gabor_filter(image, params):
    '''
    inputs: local image
            one set of params
    output: a list of size 256 with mean value for each grid(16*16)
    
    #params = [ksize, sigma, theta, lambda, gamma, psi, ktype]
    # ksize - size of gabor filter (n, n)
    # sigma - standard deviation of the gaussian function
    # theta - orientation of the normal to the parallel stripes
    # lambda - wavelength of the sunusoidal factor
    # gamma - spatial aspect ratio
    # psi - phase offset
    # ktype - type and range of values that each pixel in the gabor kernel can hold
    '''
    
    ksize = params[0]
    sigma = params[1]
    theta = params[2]
    llambda = params[3]
    gamma = params[4]
    psi = params[5]
    ktype = params[6]
    
    kern = cv2.getGaborKernel((ksize, ksize), sigma, theta, llambda, gamma, psi, ktype)
    kern /= 1.5*kern.sum()
    img = Image.open(image)
    img_ndarray = np.asarray(img)
    #img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #change to gray
    filtered_img = cv2.filter2D(img_ndarray, cv2.CV_8UC3, kern)
    #print(filtered_img)



    rows, cols = filtered_img.shape
    #image size might not be able to divide equally to 16 pieces. Modules are ignored accordingly.
    rdiv, rmod = divmod(rows,16)
    cdiv, cmod = divmod(cols,16)
    filtered_img_grid = filtered_img[0:rdiv*16, 0:cdiv*16]
    
    '''
    #print('the differences between the original image and the girded image are:', 
    #      'row size:', rows -len(filtered_img_grid), ',col size:', cols-len(filtered_img_grid[0]))
    
    pl.figure(1)
    pl.subplot(1,3,1)
    pl.imshow(img_ndarray,cmap= 'gray')
    pl.subplot(1,3,2)
    pl.imshow(filtered_img,cmap='gray')
    pl.subplot(1,3,3)
    pl.imshow(filtered_img_grid,cmap='gray')
    pl.show()
    '''
    blocked_grid = blockshaped(filtered_img_grid, rdiv, cdiv)
    
    ''' for testing
    mat = np.asarray([[1,2,3,4,5,6,7,8],
           [2,3,4,5,6,7,8,9],
           [3,4,5,6,7,8,9,10],
           [4,5,6,7,8,9,10,11]])
    newmat = blockshaped(mat, 2, 2)
    print(newmat)
    size, br, bc = newmat.shape
    list = []
    for i in range(size):
        list.append(newmat[i].mean())
    '''
    size, br, bc = blocked_grid.shape
    list = []
    for i in range(size):
        list.append(blocked_grid[i].mean())
    
    return list


def blockshaped(arr, nrows, ncols):
    """
    Return an array of shape (n, nrows, ncols) where
    n * nrows * ncols = arr.size

    If arr is a 2D array, the returned array should look like n subblocks with
    each subblock preserving the "physical" layout of arr.
    """
    h, w = arr.shape
    return (arr.reshape(h//nrows, nrows, -1, ncols)
               .swapaxes(1,2)
               .reshape(-1, nrows, ncols))
    
